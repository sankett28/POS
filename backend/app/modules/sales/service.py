from app.core.db import supabase\nfrom app.utils.bill_number import generate_bill_number\nfrom typing import Dict, Any, List\nfrom fastapi import HTTPException\nfrom decimal import Decimal\nimport uuid\n\nclass SalesService:\n    \"\"\"\n    Sales service for V1 MVP.\n    Handles sales billing with atomic stock deduction.\n    \"\"\"\n    \n    async def get_sales(self, limit: int = 100) -> Dict[str, Any]:\n        \"\"\"\n        Get recent sales bills.\n        \n        Args:\n            limit: Maximum number of bills to return\n            \n        Returns:\n            Dictionary with sales list\n        \"\"\"\n        if supabase is None:\n            return {\"sales\": []}\n        \n        try:\n            response = supabase.table(\"sales_bill\")\\\n                .select(\"*\")\\\n                .order(\"created_at\", desc=True)\\\n                .limit(limit)\\\n                .execute()\n            \n            sales = response.data if response.data else []\n            \n            # Get items for each bill\n            for sale in sales:\n                bill_id = sale[\"id\"]\n                items_response = supabase.table(\"sales_bill_items\")\\\n                    .select(\"*\")\\\n                    .eq(\"bill_id\", bill_id)\\\n                    .execute()\n                \n                sale[\"items\"] = items_response.data if items_response.data else []\n            \n            return {\"sales\": sales}\n            \n        except Exception as e:\n            raise HTTPException(\n                status_code=500,\n                detail=f\"Error fetching sales: {str(e)}\"\n            )\n    \n    async def get_bill(self, bill_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get a specific bill by ID.\n        \n        Args:\n            bill_id: UUID of the bill\n            \n        Returns:\n            Bill dictionary with items\n        \"\"\"\n        if supabase is None:\n            raise HTTPException(status_code=404, detail=\"Bill not found\")\n        \n        try:\n            bill_response = supabase.table(\"sales_bill\")\\\n                .select(\"*\")\\\n                .eq(\"id\", bill_id)\\\n                .execute()\n            \n            if not bill_response.data:\n                raise HTTPException(status_code=404, detail=\"Bill not found\")\n            \n            bill = bill_response.data[0]\n            \n            # Get items\n            items_response = supabase.table(\"sales_bill_items\")\\\n                .select(\"*\")\\\n                .eq(\"bill_id\", bill_id)\\\n                .execute()\n            \n            bill[\"items\"] = items_response.data if items_response.data else []\n            \n            return bill\n            \n        except HTTPException:\n            raise\n        except Exception as e:\n            raise HTTPException(\n                status_code=500,\n                detail=f\"Error fetching bill: {str(e)}\"\n            )\n    \n    async def create_sale(self, data: dict) -> Dict[str, Any]:\n        \"\"\"\n        Create a new sale (ATOMIC TRANSACTION).\n        \n        CRITICAL FLOW:\n        1. Generate bill_number\n        2. For each cart item:\n           - Atomically deduct stock using UPDATE with WHERE condition\n           - If rows affected = 0 â†’ abort (OUT OF STOCK)\n        3. Insert sales_bill\n        4. Insert sales_bill_items (with snapshot data)\n        5. Insert inventory_ledger entries (negative qty)\n        6. Commit transaction\n        \n        Args:\n            data: Sale data with items, payment_mode, etc.\n            \n        Returns:\n            Created bill dictionary\n        \"\"\"\n        if supabase is None:\n            raise HTTPException(status_code=503, detail=\"Database not available\")\n        \n        items = data.get(\"items\", [])\n        payment_mode = data.get(\"payment_mode\", \"cash\")\n        \n        if not items or len(items) == 0:\n            raise HTTPException(status_code=400, detail=\"Sale must have at least one item\")\n        \n        if payment_mode not in [\"cash\", \"upi\", \"card\"]:\n            raise HTTPException(\n                status_code=400,\n                detail=\"payment_mode must be one of: cash, upi, card\"\n            )\n        \n        try:\n            # STEP 1: Validate all products and get current data\n            product_data_map = {}\n            for item in items:\n                product_id = item.get(\"product_id\")\n                quantity = item.get(\"quantity\")\n                \n                if not product_id:\n                    raise HTTPException(status_code=400, detail=\"product_id is required for all items\")\n                if not quantity or quantity <= 0:\n                    raise HTTPException(status_code=400, detail=\"quantity must be positive\")\n                \n                # Fetch product data\n                product_response = supabase.table(\"products\")\\\n                    .select(\"*\")\\\n                    .eq(\"id\", product_id)\\\n                    .execute()\n                \n                if not product_response.data:\n                    raise HTTPException(\n                        status_code=404,\n                        detail=f\"Product {product_id} not found\"\n                    )\n                \n                product = product_response.data[0]\n                product_data_map[product_id] = product\n                \n                # Check stock availability\n                balance_response = supabase.table(\"inventory_balance\")\\\n                    .select(\"qty_on_hand\")\\\n                    .eq(\"product_id\", product_id)\\\n                    .execute()\n                \n                qty_on_hand = 0.0\n                if balance_response.data:\n                    qty_on_hand = float(balance_response.data[0][\"qty_on_hand\"])\n                \n                if qty_on_hand < quantity:\n                    raise HTTPException(\n                        status_code=400,\n                        detail=f\"Insufficient stock for {product[\'name\']}. Available: {qty_on_hand}, Requested: {quantity}\"\n                    )\n            \n            # STEP 2: Generate bill number\n            bill_number = generate_bill_number()\n            \n            # STEP 3: Calculate totals\n            subtotal = Decimal(\"0\")\n            tax_amount = Decimal(\"0\")\n            \n            bill_items = []\n            for item in items:\n                product_id = item[\"product_id\"]\n                quantity = Decimal(str(item[\"quantity\"]))\n                product = product_data_map[product_id]\n                \n                unit_price = Decimal(str(product[\"selling_price\"]))\n                tax_rate = Decimal(str(product.get(\"tax_rate\", 0)))\n                \n                line_subtotal = unit_price * quantity\n                line_tax = line_subtotal * (tax_rate / Decimal(\"100\"))\n                line_total = line_subtotal + line_tax\n                \n                subtotal += line_subtotal\n                tax_amount += line_tax\n                \n                bill_items.append({\n                    \"product_id\": product_id,\n                    \"product_name\": product[\"name\"],\n                    \"unit_price\": float(unit_price),\n                    \"quantity\": float(quantity),\n                    \"tax_rate\": float(tax_rate),\n                    \"line_total\": float(line_total)\n                })\n            \n            total = subtotal + tax_amount\n            \n            # STEP 4: ATOMIC STOCK DEDUCTION\n            # Use raw SQL for atomic updates with WHERE condition\n            # This ensures we don\'t oversell\n            \n            for item in items:\n                product_id = item[\"product_id\"]\n                quantity = float(item[\"quantity\"])\n                \n                # Atomic update: only succeeds if sufficient stock\n                # Using Supabase RPC or raw SQL\n                # Since Supabase Python client doesn\'t support raw SQL easily,\n                # we use a transaction approach with explicit checks\n                \n                # First, verify stock again (double-check)\n                balance_response = supabase.table(\"inventory_balance\")\\\n                    .select(\"qty_on_hand\")\\\n                    .eq(\"product_id\", product_id)\\\n                    .execute()\n                \n                current_qty = 0.0\n                if balance_response.data:\n                    current_qty = float(balance_response.data[0][\"qty_on_hand\"])\n                \n                if current_qty < quantity:\n                    raise HTTPException(\n                        status_code=400,\n                        detail=f\"Insufficient stock. Available: {current_qty}, Requested: {quantity}\"\n                    )\n                \n                # Update balance (this should be in a transaction, but Supabase client\n                # doesn\'t support transactions directly. We rely on the application-level\n                # check and hope for the best, OR we need to use Supabase RPC functions)\n                \n                # For now, we\'ll update and then verify\n                new_qty = current_qty - quantity\n                \n                update_response = supabase.table(\"inventory_balance\")\\\n                    .update({\"qty_on_hand\": new_qty})\\\n                    .eq(\"product_id\", product_id)\\\n                    .eq(\"qty_on_hand\", current_qty)\\\  # Optimistic locking\n                    .execute()\n                \n                # If no rows updated, stock was changed by another transaction\n                if not update_response.data:\n                    raise HTTPException(\n                        status_code=409,\n                        detail=f\"Stock conflict for product {product_id}. Please retry.\"\n                    )\n            \n            # STEP 5: Create sales bill\n            bill_data = {\n                \"bill_number\": bill_number,\n                \"subtotal\": float(subtotal),\n                \"tax_amount\": float(tax_amount),\n                \"total\": float(total),\n                \"payment_mode\": payment_mode\n            }\n            \n            bill_response = supabase.table(\"sales_bill\")\\\n                .insert(bill_data)\\\n                .execute()\n            \n            if not bill_response.data:\n                # Rollback stock updates (manual rollback needed)\n                # In production, use database transactions\n                raise HTTPException(\n                    status_code=500,\n                    detail=\"Failed to create bill. Stock may have been deducted.\"\n                )\n            \n            bill_id = bill_response.data[0][\"id\"]\n            \n            # STEP 6: Create bill items (with snapshot data)\n            items_to_insert = []\n            for item in bill_items:\n                items_to_insert.append({\n                    \"bill_id\": bill_id,\n                    \"product_id\": item[\"product_id\"],\n                    \"product_name\": item[\"product_name\"],\n                    \"unit_price\": item[\"unit_price\"],\n                    \"quantity\": item[\"quantity\"],\n                    \"tax_rate\": item[\"tax_rate\"],\n                    \"line_total\": item[\"line_total\"]\n                })\n            \n            supabase.table(\"sales_bill_items\")\\\n                .insert(items_to_insert)\\\n                .execute()\n            \n            # STEP 7: Create ledger entries (negative qty for stock out)\n            ledger_entries = []\n            for item in items:\n                ledger_entries.append({\n                    \"product_id\": item[\"product_id\"],\n                    \"qty_delta\": -float(item[\"quantity\"]),  # Negative for stock out\n                    \"reason\": \"SALE\",\n                    \"reference_id\": bill_id,\n                    \"notes\": f\"Sale: {bill_number}\"\n                })\n            \n            supabase.table(\"inventory_ledger\")\\\n                .insert(ledger_entries)\\\n                .execute()\n            \n            # Fetch complete bill with items\n            bill = bill_response.data[0]\n            bill[\"items\"] = items_to_insert\n            \n            return {\n                \"success\": True,\n                \"bill\": bill\n            }\n            \n        except HTTPException:\n            raise\n        except Exception as e:\n            raise HTTPException(\n                status_code=500,\n                detail=f\"Error creating sale: {str(e)}\"\n            )\n    \n    async def create_bill(self, data: dict) -> Dict[str, Any]:\n        \"\"\"\n        Legacy endpoint alias for create_sale.\n        \"\"\"\n        return await self.create_sale(data)\n    \n    async def get_recent_bills(self, limit: int = 10) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get recent bills (legacy endpoint).\n        \n        Args:\n            limit: Maximum number of bills to return\n            \n        Returns:\n            List of bill summaries\n        \"\"\"\n        if supabase is None:\n            return []\n        \n        try:\n            response = supabase.table(\"sales_bill\")\\\n                .select(\"id, bill_number, total, created_at\")\\\n                .order(\"created_at\", desc=True)\\\n                .limit(limit)\\\n                .execute()\n            \n            bills = []\n            for bill in (response.data if response.data else []):\n                # Count items\n                items_response = supabase.table(\"sales_bill_items\")\\\n                    .select(\"id\")\\\n                    .eq(\"bill_id\", bill[\"id\"])\\\n                    .execute()\n                \n                item_count = len(items_response.data) if items_response.data else 0\n                \n                bills.append({\n                    \"id\": bill[\"id\"],\n                    \"invoiceNumber\": bill[\"bill_number\"],\n                    \"total\": float(bill[\"total\"]),\n                    \"items\": item_count,\n                    \"timestamp\": bill[\"created_at\"]\n                })\n            \n            return bills\n            \n        except Exception as e:\n            raise HTTPException(\n                status_code=500,\n                detail=f\"Error fetching bills: {str(e)}\"\n            )
